"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createXHRHandler = void 0;
const util_1 = require("./util");
const pendingRequests = new Map();
const hiRequestId = Symbol('__hiRequestId');
const createXHRHandler = (emitter) => {
    const construct = {
        construct: (target, argArray, newTarget) => {
            const requestId = (0, util_1.randomId)();
            newTarget.prototype[hiRequestId] = requestId;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return Reflect.construct(target, argArray, newTarget);
        },
    };
    const open = {
        apply: (target, thisArg, argumentsList) => {
            const requestId = thisArg[hiRequestId];
            if (!requestId)
                return Reflect.apply(target, thisArg, argumentsList);
            const [method, urlObj] = argumentsList;
            const url = urlObj.toString();
            // TODO: create headers
            const reqHeaders = {};
            pendingRequests.set(requestId, { method, url, headers: reqHeaders });
            Reflect.apply(target, thisArg, argumentsList);
        },
    };
    const send = {
        apply: (target, thisArg, argumentsList) => {
            const requestId = thisArg[hiRequestId];
            if (!requestId)
                return Reflect.apply(target, thisArg, argumentsList);
            const timestamp = Date.now();
            const request = pendingRequests.get(requestId);
            if (!request)
                return Reflect.apply(target, thisArg, argumentsList);
            emitter.emit('networkRequestHasBeenMade', {
                type: 'xhr',
                timestamp,
                requestId,
                request,
            });
            const onReadyStateChange = () => {
                switch (thisArg.readyState) {
                    case XMLHttpRequest.DONE: {
                        const end = Date.now();
                        const headerString = thisArg.getAllResponseHeaders();
                        const headers = headerString.split('\n').reduce((prev, cur) => {
                            const [key, value] = cur.split(': ');
                            return Object.assign(Object.assign({}, prev), { [key]: value });
                        }, {});
                        emitter.emit('networkRequestHasSucceeded', {
                            type: 'xhr',
                            timestamp: end,
                            requestId,
                            response: {
                                url: request.url,
                                statusCode: thisArg.status,
                                status: thisArg.statusText,
                                headers,
                                rawData: thisArg.response,
                                text: thisArg.response,
                            },
                        });
                        break;
                    }
                    default:
                        break;
                }
            };
            thisArg.onreadystatechange = thisArg.onreadystatechange
                ? new Proxy(thisArg.onreadystatechange, {
                    apply: (target, thisArg, argumentsList) => {
                        onReadyStateChange();
                        return Reflect.apply(target, thisArg, argumentsList);
                    },
                })
                : onReadyStateChange;
            return Reflect.apply(target, thisArg, argumentsList);
        },
    };
    return { construct, open, send };
};
exports.createXHRHandler = createXHRHandler;
