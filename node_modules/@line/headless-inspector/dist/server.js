"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runServer = exports.parseArgv = exports.getPrivateIp = void 0;
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const ws_1 = __importDefault(require("ws"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const SocketMap_1 = require("./SocketMap");
const yargs_1 = __importDefault(require("yargs/yargs"));
const fs_1 = __importDefault(require("fs"));
const util_1 = __importDefault(require("util"));
const debuglog = util_1.default.debuglog('debug');
const log = console.log;
const getPrivateIp = () => {
    var _a;
    const ifaces = os_1.default.networkInterfaces();
    const ipAddress = (_a = Object.values(ifaces)
        .flat()
        .find((iface) => !!iface && iface.family === 'IPv4' && iface.internal === false)) === null || _a === void 0 ? void 0 : _a.address;
    return ipAddress;
};
exports.getPrivateIp = getPrivateIp;
const parseArgv = (processArgv) => {
    const argv = (0, yargs_1.default)(processArgv.slice(2)).options({
        key: { type: 'string' },
        cert: { type: 'string' },
        https: { type: 'boolean' },
    }).argv;
    let ssl = argv.key && argv.cert
        ? {
            key: fs_1.default.readFileSync(path_1.default.resolve(process.cwd(), argv.key)),
            cert: fs_1.default.readFileSync(path_1.default.resolve(process.cwd(), argv.cert)),
        }
        : undefined;
    if (argv.https && !ssl) {
        debuglog('generate SSL certificates');
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const selfsigned = require('selfsigned');
        const attrs = [{ name: 'commonName', value: 'localhost' }];
        const pems = selfsigned.generate(attrs, {
            days: 365,
            algorithm: 'sha256',
            keySize: 2048,
            extensions: [
                {
                    name: 'basicConstraints',
                    cA: true,
                },
                {
                    name: 'keyUsage',
                    keyCertSign: true,
                    digitalSignature: true,
                    nonRepudiation: true,
                    keyEncipherment: true,
                    dataEncipherment: true,
                },
                {
                    name: 'extKeyUsage',
                    serverAuth: true,
                    clientAuth: true,
                    codeSigning: true,
                    timeStamping: true,
                },
            ],
        });
        // TODO: save as cache
        const cert = `${pems.private}${pems.cert}`;
        ssl = {
            key: cert,
            cert: cert,
        };
    }
    return {
        ssl,
    };
};
exports.parseArgv = parseArgv;
const runServer = ({ port, devInfo = [], ssl }, onListen) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const serveDevInfo = (req, res) => {
        res.json([devInfo]);
    };
    const server = createServer(createApp((app) => {
        app.use('/', express_1.default.static(path_1.default.resolve(__dirname, '../dist/umd')));
        app.get('/json', serveDevInfo);
        app.get('/json/list', serveDevInfo);
    }), ssl);
    server.on('error', (e) => {
        debuglog('error', e);
    });
    server.listen(port, () => {
        if (onListen)
            onListen();
    });
    const wsServer = new ws_1.default.Server({ server });
    wsServer.on('error', (msg) => {
        debuglog('error', msg);
    });
    wsServer.on('close', () => {
        debuglog('close wsServer');
    });
    wsServer.on('connection', (socket, req) => {
        onConnection(socket, req, !!ssl);
    });
};
exports.runServer = runServer;
const createApp = (callback) => {
    const app = (0, express_1.default)();
    callback(app);
    return app;
};
const createServer = (app, ssl) => {
    const server = ssl
        ? https_1.default.createServer({ key: ssl.key, cert: ssl.cert }, app)
        : http_1.default.createServer(app);
    return server;
};
const socketMap = new SocketMap_1.SocketMap();
const onConnection = (socket, req, ssl) => {
    var _a;
    const type = /^(chrome|devtools):\/\//.test((_a = req.headers.origin) !== null && _a !== void 0 ? _a : '')
        ? 'devtool'
        : 'client';
    if (!req.url) {
        debuglog('req.url not found');
        return;
    }
    const requestUrl = new URL(req.url, `http://${req.headers.host}`);
    const hiId = requestUrl.searchParams.get('hi_id');
    if (!hiId) {
        throw new Error('headless inspector id is missing');
    }
    log(`connection from ${type}, id: ${hiId}`);
    if (type === 'client') {
        const isSecure = req.headers['x-forwarded-proto'] === 'https';
        const protocol = isSecure || ssl ? 'wss' : 'ws';
        const url = `devtools://devtools/bundled/inspector.html?${protocol}=${req.headers.host}/?hi_id=${hiId}`;
        console.log('DevTools URL: \x1b[36m%s\x1b[0m', `${url}`);
    }
    socketMap.set(hiId, socket, type);
    const timer = setInterval(() => {
        socket.ping();
    }, 10000);
    socket.on('error', (e) => {
        debuglog('error', e);
        socketMap.remove(hiId, socket, type);
    });
    socket.on('close', (e) => {
        debuglog('close', e);
        clearInterval(timer);
        socketMap.remove(hiId, socket, type);
    });
    socket.on('message', (msg) => {
        var _a;
        const target = type === 'client' ? 'devtool' : 'client';
        (_a = socketMap.get(hiId)) === null || _a === void 0 ? void 0 : _a[target].forEach((s) => {
            if (s !== socket) {
                s.send(msg.toString());
            }
        });
    });
};
